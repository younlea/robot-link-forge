import re
from typing import Dict, List
from robot_models import RobotData

def inject_gazebo_tags(urdf_content: str, robot: RobotData) -> str:
    """
    Injects Gazebo-specific tags into the URDF content.
    - Adds <gazebo> materials for links.
    - Adds a <gazebo> plugin for ros_control.
    """
    
    # 1. Add Gazebo Materials for Links
    # We find where </link> is and insert <gazebo reference="..."><material>...</material></gazebo> after it?
    # Or cleaner: Just append all gazebo tags at the end of the <robot> block, before </robot>.
    
    gazebo_tags = "\n  <!-- Gazebo-specific Link Properties -->\n"
    
    for link_id, link in robot.links.items():
        # Clean name resolution is tough if we don't pass the map.
        # However, the URDF content already has the sanitized names.
        # We need the sanitized names to reference them. 
        # Since we don't have the map here easily without passing it, 
        # let's rely on parsing valid names or assume standard naming convention if possible?
        # BETTER: Pass the unique_link_names map if possible.
        # BUT: For simplicity, we can inject these tags into the standard URDF generator OR
        # rely on the fact that we can append generic tags if we know the names.
        
        # Let's assume the caller passes generic content. 
        # Actually, let's just append a generic ROS Control plugin which is global.
        pass
        
    # Since we need to know the exact link names generated by the URDF exporter to reference them,
    # it's safer if we just add the global plugin for now.
    # Individual link materials are nice but not strictly required for "testing in Gazebo".
    # The default URDF materials usually show up in Gazebo (sometimes white/grey).
    
    # Let's add the control plugin which is essential for moving joints.
    gazebo_plugin = """
  <!-- Gazebo ROS Control Plugin -->
  <gazebo>
    <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
      <robotNamespace>/</robotNamespace>
    </plugin>
  </gazebo>
"""
    
    # Insert before </robot>
    if "</robot>" in urdf_content:
        urdf_content = urdf_content.replace("</robot>", f"{gazebo_plugin}\n</robot>")
        
    return urdf_content

def generate_gazebo_launch(robot_name: str) -> str:
    """Generates a standard ROS 1 launch file for Gazebo."""
    launch_xml = f"""<launch>
  <!-- Argument for GUI -->
  <arg name="gui" default="true"/>
  <arg name="paused" default="false"/>

  <!-- Launch Gazebo World -->
  <include file="$(find gazebo_ros)/launch/empty_world.launch">
    <arg name="gui" value="$(arg gui)" />
    <arg name="paused" value="$(arg paused)"/>
    <arg name="use_sim_time" value="true"/>
  </include>

  <!-- Load Robot Description -->
  <param name="robot_description" textfile="$(find {robot_name})/urdf/{robot_name}.urdf" />

  <!-- Spawn Robot -->
  <node name="urdf_spawner" pkg="gazebo_ros" type="spawn_model" respawn="false" output="screen"
        args="-urdf -model {robot_name} -param robot_description"/>
        
  <!-- Robot State Publisher -->
  <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher">
    <param name="publish_frequency" type="double" value="50.0" />
  </node>
  
  <!-- Joint State Publisher (Fake for validation if no controllers) -->
  <!-- <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher" /> -->

</launch>
"""
    return launch_xml

def inject_gazebo_ros2_tags(urdf_content: str, robot: RobotData) -> str:
    """
    Injects Gazebo-specific tags for ROS 2.
    - Adds <gazebo> materials (same as ROS 1 usually).
    - Adds <gazebo> plugin for ros2_control.
    """
    
    # 1. Add generic Gazebo tags (materials) - mostly same as ROS 1
    # For now we skip specific link materials unless we parse names.
    
    # 2. Add gazebo_ros2_control plugin
    # Note: filename is usually libgazebo_ros2_control.so
    gazebo_plugin = """
  <!-- Gazebo ROS 2 Control Plugin -->
  <gazebo>
    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">
      <parameters>$(find {robot_name})/config/ros2_controllers.yaml</parameters>
    </plugin>
  </gazebo>
"""
    # Note: We need {robot_name} to be valid, but here we don't have it easily injected in this string.
    # actually we usually put the yaml path.
    # However, without a controller yaml generated, the plugin might complain or default.
    # A safer minimal plugin for just "visualizing" in Gazebo without complex controllers:
    # Actually, standard DiffDrive or just JointStatePublisher is easier for a start.
    
    # Let's use a generic configuration that doesn't hard-crash if config is missing, 
    # or just omit the parameters tag to let it use defaults/parameters server.
    
    minimal_plugin = """
  <gazebo>
    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">
      <robot_param>robot_description</robot_param>
      <robot_param_node>robot_state_publisher</robot_param_node>
      <parameters>$(find {robot_name})/config/ros2_controllers.yaml</parameters>
    </plugin>
  </gazebo>
"""
    # To keep it simple for the user who hasn't defined controllers in our UI:
    # We will just inject the plugin definition. The user will have to create the config
    # if they want to actually move it, OR we generate a dummy config.
    # For now, let's just stick to the basic plugin injection.
    
    gazebo_plugin_formatted = """
  <!-- Gazebo ROS 2 Control Plugin -->
  <gazebo>
    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">
      <!-- <parameters>$(find pkg_name)/config/controllers.yaml</parameters> -->
    </plugin>
  </gazebo>
"""

    if "</robot>" in urdf_content:
        urdf_content = urdf_content.replace("</robot>", f"{gazebo_plugin_formatted}\n</robot>")
        
    return urdf_content

def generate_gazebo_ros2_launch(robot_name: str) -> str:
    """Generates a Python launch file for ROS 2 Gazebo."""
    
    # We need to find the package share directory.
    # We launch gazebo_ros -> gazebo.launch.py
    # We spawn_entity.py
    # We robot_state_publisher
    
    launch_py = f"""
import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import ExecuteProcess, IncludeLaunchDescription, RegisterEventHandler
from launch.event_handlers import OnProcessExit
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import Command, FindExecutable, PathJoinSubstitution
from launch_ros.actions import Node

def generate_launch_description():
    pkg_name = '{robot_name}'
    pkg_share = get_package_share_directory(pkg_name)
    
    # Gazebo Launch
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(get_package_share_directory('gazebo_ros'), 'launch', 'gazebo.launch.py')
        ),
    )

    # Robot State Publisher
    # We assume urdf is in urdf/ directory
    urdf_file = os.path.join(pkg_share, 'urdf', '{robot_name}.urdf')
    
    # Make sure we read the URDF content for the parameter
    # Note: In ROS 2, it is often preferred to use 'Command' with xacro, even for pure URDF, 
    # but reading text is fine for plain URDF.
    
    with open(urdf_file, 'r') as infp:
        robot_desc = infp.read()

    node_robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        output='screen',
        parameters=[{{'robot_description': robot_desc}}],
    )

    # Spawn Entity
    spawn_entity = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=['-topic', 'robot_description',
                   '-entity', '{robot_name}'],
        output='screen'
    )

    return LaunchDescription([
        gazebo,
        node_robot_state_publisher,
        spawn_entity,
    ])
"""
    return launch_py

